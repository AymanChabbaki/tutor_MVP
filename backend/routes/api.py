import asyncio
import logging
from functools import wraps
from flask import Blueprint, request, jsonify, current_app
from services.gemini_service import gemini_service
from services.session_service import session_service
from services.collection_service import collection_service
from middleware.auth_middleware import auth_required_async, get_current_user, optional_auth
from db.database import db_service

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create API blueprint
api_bp = Blueprint('api', __name__)

def async_route(f):
    """Decorator to handle async routes in Flask."""
    @wraps(f)
    def wrapper(*args, **kwargs):
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                return loop.run_until_complete(f(*args, **kwargs))
            finally:
                loop.close()
        except Exception as e:
            logger.error(f"Error in async route {f.__name__}: {e}")
            return jsonify({
                'error': 'Internal server error',
                'message': str(e)
            }), 500
    return wrapper

def validate_json_input(required_fields):
    """Decorator to validate JSON input."""
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # Handle OPTIONS requests for CORS
            if request.method == 'OPTIONS':
                return '', 200
                
            if not request.is_json:
                return jsonify({
                    'error': 'Content-Type must be application/json'
                }), 400
            
            data = request.get_json()
            if not data:
                return jsonify({
                    'error': 'Request body must contain valid JSON'
                }), 400
            
            for field in required_fields:
                if field not in data:
                    return jsonify({
                        'error': f'Missing required field: {field}'
                    }), 400
                
                if not data[field] or not str(data[field]).strip():
                    return jsonify({
                        'error': f'Field {field} cannot be empty'
                    }), 400
            
            return f(*args, **kwargs)
        return wrapper
    return decorator

@api_bp.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({
        'status': 'healthy',
        'service': 'AI Bootcamp Tutor V2',
        'version': '2.0.0',
        'features': [
            'JWT Authentication',
            'Session Management',
            'Collections',
            'Multi-language Support',
            'Gemini AI Integration'
        ]
    }), 200

@api_bp.route('/summarize', methods=['POST', 'OPTIONS'])
@validate_json_input(['text'])
@optional_auth
@async_route
async def summarize_content():
    """
    Summarize course content using Gemini AI.
    Authentication optional - if provided, session will be saved.
    
    Expected input:
    {
        "text": "copied course content or headings",
        "language_preference": "arabic" | "english" | "both"  // optional, defaults to "english"
    }
    
    Returns:
    {
        "summary": "short summary generated by Gemini",
        "session_id": 123  // only if authenticated
    }
    """
    try:
        data = request.get_json()
        input_text = data['text'].strip()
        language_preference = data.get('language_preference', 'english').lower()
        
        # Get current user if authenticated
        current_user = get_current_user()
        user_id = current_user['user_id'] if current_user and current_user.get('user_id') else None
        
        logger.info(f"Summarizing content for user {user_id} in {language_preference}: {len(input_text)} characters")
        
        # Generate summary using Gemini AI
        summary = await gemini_service.summarize_content(input_text, language_preference)
        
        # Store in database if user is authenticated
        session_id = None
        if user_id:
            try:
                result = await session_service.create_summary_session(
                    user_id=user_id,
                    text=input_text,
                    language=language_preference
                )
                if result.get('success'):
                    session_id = result['session']['id']
                    logger.info(f"Stored summary session {session_id} for user {user_id}")
                else:
                    logger.warning(f"Failed to store session: {result.get('error')}")
            except Exception as db_error:
                logger.warning(f"Failed to store session in database: {db_error}")
                # Continue even if database storage fails
        
        response = {
            'summary': summary,
            'language': language_preference
        }
        
        if session_id:
            response['session_id'] = session_id
        
        return jsonify(response), 200
        
    except ValueError as e:
        logger.warning(f"Validation error in summarize: {e}")
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in summarize endpoint: {e}")
        return jsonify({
            'error': 'Failed to generate summary',
            'message': str(e)
        }), 500

@api_bp.route('/explain', methods=['POST', 'OPTIONS'])
@validate_json_input(['text'])
@optional_auth
@async_route
async def explain_content():
    """
    Explain course content based on language preference.
    Authentication optional - if provided, session will be saved.
    
    Expected input:
    {
        "text": "copied course content or headings",
        "language_preference": "arabic" | "english" | "both"  // optional, defaults to "english"
    }
    
    Returns:
    {
        "explanation": "explanation in the requested language",
        "session_id": 123  // only if authenticated
    }
    """
    try:
        data = request.get_json()
        input_text = data['text'].strip()
        language_preference = data.get('language_preference', 'english').lower()
        
        # Get current user if authenticated
        current_user = get_current_user()
        user_id = current_user['user_id'] if current_user and current_user.get('user_id') else None
        
        logger.info(f"Explaining content for user {user_id} in {language_preference}: {len(input_text)} characters")
        
        # Generate explanation using Gemini AI 
        explanation = await gemini_service.explain_content(input_text, language_preference)
        
        response = {
            'explanation': explanation,
            'language': language_preference
        }
        
        # Store in database if user is authenticated
        session_id = None
        if user_id:
            try:
                result = await session_service.create_explanation_session(
                    user_id=user_id,
                    text=input_text,
                    language=language_preference
                )
                if result.get('success'):
                    session_id = result['session']['id']
                    logger.info(f"Stored explanation session {session_id} for user {user_id}")
                    response['session_id'] = session_id
                else:
                    logger.warning(f"Failed to store session: {result.get('error')}")
            except Exception as db_error:
                logger.warning(f"Failed to store session in database: {db_error}")
                # Continue even if database storage fails
        
        return jsonify(response), 200
        
    except ValueError as e:
        logger.warning(f"Validation error in explain: {e}")
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in explain endpoint: {e}")
        return jsonify({
            'error': 'Failed to generate explanation',
            'message': str(e)
        }), 500

@api_bp.route('/generate_exercises', methods=['POST', 'OPTIONS'])
@validate_json_input(['text'])
@optional_auth
@async_route
async def generate_exercises():
    """
    Generate educational exercises based on course content.
    Authentication optional - if provided, session will be saved.
    
    Expected input:
    {
        "text": "copied course content or headings",
        "language_preference": "arabic" | "english" | "both"  // optional, defaults to "english"
    }
    
    Returns:
    {
        "exercises": [...],
        "session_id": 123  // only if authenticated
    }
    """
    try:
        data = request.get_json()
        input_text = data['text'].strip()
        language_preference = data.get('language_preference', 'english').lower()
        
        # Get current user if authenticated
        current_user = get_current_user()
        user_id = current_user['user_id'] if current_user and current_user.get('user_id') else None
        
        logger.info(f"Generating exercises for user {user_id} in {language_preference}: {len(input_text)} characters")
        
        # Generate exercises using Gemini AI
        exercises = await gemini_service.generate_exercises(input_text, language_preference)
        
        response = {
            'exercises': exercises,
            'language': language_preference
        }
        
        # Store in database if user is authenticated
        session_id = None
        if user_id:
            try:
                result = await session_service.create_exercises_session(
                    user_id=user_id,
                    text=input_text,
                    language=language_preference
                )
                if result.get('success'):
                    session_id = result['session']['id']
                    logger.info(f"Stored exercises session {session_id} for user {user_id}")
                    response['session_id'] = session_id
                else:
                    logger.warning(f"Failed to store session: {result.get('error')}")
            except Exception as db_error:
                logger.warning(f"Failed to store session in database: {db_error}")
                # Continue even if database storage fails
        
        return jsonify(response), 200
        
    except ValueError as e:
        logger.warning(f"Validation error in generate_exercises: {e}")
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in generate_exercises endpoint: {e}")
        return jsonify({
            'error': 'Failed to generate exercises',
            'message': str(e)
        }), 500

# Protected routes for authenticated users

@api_bp.route('/sessions', methods=['GET'])
@auth_required_async
async def get_user_sessions():
    """
    Get current user's sessions.
    Requires authentication.
    
    Query parameters:
    - limit: number of sessions to return (max 100, default 20)
    - collection_id: filter by collection ID (optional)
    
    Returns:
    {
        "sessions": [...],
        "total": 150,
        "limit": 20
    }
    """
    try:
        current_user = get_current_user()
        limit = min(request.args.get('limit', 20, type=int), 100)
        collection_id = request.args.get('collection_id', type=int)
        
        sessions = await session_service.get_user_sessions(
            user_id=current_user['user_id'],
            limit=limit,
            collection_id=collection_id
        )
        
        return jsonify({
            'sessions': sessions,
            'limit': limit
        }), 200
        
    except Exception as e:
        logger.error(f"Error in get_user_sessions endpoint: {e}")
        return jsonify({
            'error': 'Failed to retrieve sessions',
            'message': str(e)
        }), 500

@api_bp.route('/sessions/<int:session_id>', methods=['GET'])
@auth_required_async
async def get_session(session_id):
    """
    Get a specific session.
    Requires authentication and ownership.
    """
    try:
        current_user = get_current_user()
        
        result = await session_service.get_session_by_id(session_id, current_user['user_id'])
        
        if not result:
            return jsonify({
                'error': 'Session not found or access denied'
            }), 404
        
        return jsonify(result), 200
        
    except Exception as e:
        logger.error(f"Error in get_session endpoint: {e}")
        return jsonify({
            'error': 'Failed to retrieve session',
            'message': str(e)
        }), 500

@api_bp.route('/sessions/<int:session_id>', methods=['DELETE'])
@auth_required_async
async def delete_session(session_id):
    """
    Delete a specific session.
    Requires authentication and ownership.
    """
    try:
        current_user = get_current_user()
        
        success = await session_service.delete_session(session_id, current_user['user_id'])
        if not success:
            return jsonify({
                'error': 'Session not found or access denied'
            }), 404
        
        return jsonify({
            'message': 'Session deleted successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Error in delete_session endpoint: {e}")
        return jsonify({
            'error': 'Failed to delete session',
            'message': str(e)
        }), 500

# Collection management routes

@api_bp.route('/collections', methods=['GET'])
@auth_required_async
async def get_user_collections():
    """
    Get current user's collections.
    Requires authentication.
    """
    try:
        logger.info("Starting get_user_collections endpoint")
        current_user = get_current_user()
        logger.info(f"Current user: {current_user}")
        
        user_id = current_user['user_id']
        logger.info(f"Calling collection_service.get_user_collections with user_id: {user_id}")
        
        result = await collection_service.get_user_collections(user_id)
        logger.info(f"Collection service result: {result}")
        
        if not result.get('success'):
            logger.error(f"Collection service returned error: {result.get('error')}")
            return jsonify({
                'error': 'Failed to retrieve collections',
                'message': result.get('error', 'Unknown error')
            }), 500
        
        logger.info("Collections retrieved successfully")
        return jsonify({
            'collections': result.get('collections', [])
        }), 200
        
    except Exception as e:
        logger.error(f"Error in get_user_collections endpoint: {e}", exc_info=True)
        return jsonify({
            'error': 'Failed to retrieve collections',
            'message': str(e)
        }), 500

@api_bp.route('/collections', methods=['POST'])
@validate_json_input(['name'])
@auth_required_async
async def create_collection():
    """
    Create a new collection.
    Requires authentication.
    
    Expected input:
    {
        "name": "Collection Name",
        "description": "Optional description"
    }
    """
    try:
        current_user = get_current_user()
        data = request.get_json()
        
        result = await collection_service.create_collection(
            user_id=current_user['user_id'],
            title=data['name'].strip(),
            description=data.get('description', '').strip()
        )
        
        if not result.get('success'):
            return jsonify({
                'error': 'Failed to create collection',
                'message': result.get('error', 'Unknown error')
            }), 500
        
        return jsonify({
            'collection': result.get('collection')
        }), 201
        
    except ValueError as e:
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in create_collection endpoint: {e}")
        return jsonify({
            'error': 'Failed to create collection',
            'message': str(e)
        }), 500

@api_bp.route('/collections/<int:collection_id>', methods=['PUT'])
@validate_json_input(['name'])
@auth_required_async
async def update_collection(collection_id):
    """
    Update a collection.
    Requires authentication and ownership.
    """
    try:
        current_user = get_current_user()
        data = request.get_json()
        
        result = await collection_service.update_collection(
            collection_id=collection_id,
            user_id=current_user['user_id'],
            title=data['name'].strip(),
            description=data.get('description', '').strip()
        )
        
        if not result.get('success'):
            error_message = result.get('error', 'Unknown error')
            if error_message == 'Collection not found':
                return jsonify({
                    'error': 'Collection not found or access denied'
                }), 404
            return jsonify({
                'error': 'Failed to update collection',
                'message': error_message
            }), 500
        
        return jsonify({
            'collection': result.get('collection')
        }), 200
        
    except ValueError as e:
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in update_collection endpoint: {e}")
        return jsonify({
            'error': 'Failed to update collection',
            'message': str(e)
        }), 500

@api_bp.route('/collections/<int:collection_id>', methods=['DELETE'])
@auth_required_async
async def delete_collection(collection_id):
    """
    Delete a collection.
    Requires authentication and ownership.
    """
    try:
        current_user = get_current_user()
        
        result = await collection_service.delete_collection(collection_id, current_user['user_id'])
        if not result.get('success'):
            error_message = result.get('error', 'Unknown error')
            if error_message == 'Collection not found':
                return jsonify({
                    'error': 'Collection not found or access denied'
                }), 404
            return jsonify({
                'error': 'Failed to delete collection',
                'message': error_message
            }), 500
        
        return jsonify({
            'message': 'Collection deleted successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Error in delete_collection endpoint: {e}")
        return jsonify({
            'error': 'Failed to delete collection',
            'message': str(e)
        }), 500

@api_bp.route('/collections/<int:collection_id>/sessions/<int:session_id>', methods=['POST'])
@auth_required_async
async def add_session_to_collection(collection_id, session_id):
    """
    Add a session to a collection.
    Requires authentication and ownership of both session and collection.
    """
    try:
        current_user = get_current_user()
        
        result = await collection_service.add_session_to_collection(
            collection_id=collection_id,
            session_id=session_id,
            user_id=current_user['user_id']
        )
        
        if not result.get('success'):
            error_message = result.get('error', 'Unknown error')
            if 'not found' in error_message.lower():
                return jsonify({
                    'error': 'Session or collection not found, or access denied'
                }), 404
            return jsonify({
                'error': 'Failed to add session to collection',
                'message': error_message
            }), 500
        
        return jsonify({
            'message': 'Session added to collection successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Error in add_session_to_collection endpoint: {e}")
        return jsonify({
            'error': 'Failed to add session to collection',
            'message': str(e)
        }), 500

@api_bp.route('/collections/<int:collection_id>/sessions/<int:session_id>', methods=['DELETE'])
@auth_required_async
async def remove_session_from_collection(collection_id, session_id):
    """
    Remove a session from a collection.
    Requires authentication and ownership.
    """
    try:
        current_user = get_current_user()
        
        result = await collection_service.remove_session_from_collection(
            session_id=session_id,
            user_id=current_user['user_id']
        )
        
        if not result.get('success'):
            error_message = result.get('error', 'Unknown error')
            if 'not found' in error_message.lower():
                return jsonify({
                    'error': 'Session or collection not found, or access denied'
                }), 404
            return jsonify({
                'error': 'Failed to remove session from collection',
                'message': error_message
            }), 500
        
        return jsonify({
            'message': 'Session removed from collection successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Error in remove_session_from_collection endpoint: {e}")
        return jsonify({
            'error': 'Failed to remove session from collection',
            'message': str(e)
        }), 500

# Error handlers

@api_bp.errorhandler(404)
def not_found(error):
    """Handle 404 errors."""
    return jsonify({
        'error': 'Not found',
        'message': 'The requested resource was not found'
    }), 404

@api_bp.errorhandler(405)
def method_not_allowed(error):
    """Handle 405 errors."""
    return jsonify({
        'error': 'Method not allowed',
        'message': 'The method is not allowed for the requested URL'
    }), 405

@api_bp.errorhandler(500)
def internal_error(error):
    """Handle 500 errors."""
    logger.error(f"Internal server error: {error}")
    return jsonify({
        'error': 'Internal server error',
        'message': 'An unexpected error occurred'
    }), 500
