import asyncio
import logging
from functools import wraps
from flask import Blueprint, request, jsonify, current_app
from services.gemini_service import gemini_service
from db.database import db_service

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create API blueprint
api_bp = Blueprint('api', __name__)

def async_route(f):
    """Decorator to handle async routes in Flask."""
    @wraps(f)
    def wrapper(*args, **kwargs):
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                return loop.run_until_complete(f(*args, **kwargs))
            finally:
                loop.close()
        except Exception as e:
            logger.error(f"Error in async route {f.__name__}: {e}")
            return jsonify({
                'error': 'Internal server error',
                'message': str(e)
            }), 500
    return wrapper

def validate_json_input(required_fields):
    """Decorator to validate JSON input."""
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # Handle OPTIONS requests for CORS
            if request.method == 'OPTIONS':
                return '', 200
                
            if not request.is_json:
                return jsonify({
                    'error': 'Content-Type must be application/json'
                }), 400
            
            data = request.get_json()
            if not data:
                return jsonify({
                    'error': 'Request body must contain valid JSON'
                }), 400
            
            for field in required_fields:
                if field not in data:
                    return jsonify({
                        'error': f'Missing required field: {field}'
                    }), 400
                
                if not data[field] or not str(data[field]).strip():
                    return jsonify({
                        'error': f'Field {field} cannot be empty'
                    }), 400
            
            return f(*args, **kwargs)
        return wrapper
    return decorator

@api_bp.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({
        'status': 'healthy',
        'service': 'AI Bootcamp Tutor MVP',
        'version': '1.0.0'
    }), 200

@api_bp.route('/summarize', methods=['POST', 'OPTIONS'])
@validate_json_input(['text'])
@async_route
async def summarize_content():
    """
    Summarize course content using Gemini AI.
    
    Expected input:
    {
        "text": "copied course content or headings",
        "user_id": 1,  // optional
        "language_preference": "arabic" | "english"  // optional, defaults to "english"
    }
    
    Returns:
    {
        "summary": "short summary generated by Gemini"
    }
    """
    try:
        data = request.get_json()
        input_text = data['text'].strip()
        user_id = data.get('user_id')
        language_preference = data.get('language_preference', 'english').lower()
        
        logger.info(f"Summarizing content for user {user_id} in {language_preference}: {len(input_text)} characters")
        
        # Generate summary using Gemini AI
        summary = await gemini_service.summarize_content(input_text, language_preference)
        
        # Store in database if user_id is provided
        session_id = None
        if user_id:
            try:
                session = await db_service.create_session(
                    user_id=user_id,
                    input_text=input_text,
                    output_summary=summary
                )
                session_id = session['id']
                logger.info(f"Stored summary session {session_id} for user {user_id}")
            except Exception as db_error:
                logger.warning(f"Failed to store session in database: {db_error}")
                # Continue even if database storage fails
        
        response = {
            'summary': summary
        }
        
        if session_id:
            response['session_id'] = session_id
        
        return jsonify(response), 200
        
    except ValueError as e:
        logger.warning(f"Validation error in summarize: {e}")
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in summarize endpoint: {e}")
        return jsonify({
            'error': 'Failed to generate summary',
            'message': str(e)
        }), 500

@api_bp.route('/explain', methods=['POST', 'OPTIONS'])
@validate_json_input(['text'])
@async_route
async def explain_content():
    """
    Explain course content based on language preference.
    
    Expected input:
    {
        "text": "copied course content or headings",
        "user_id": 1,  // optional
        "language_preference": "arabic" | "english"  // optional, defaults to "english"
    }
    
    Returns:
    {
        "explanation": "explanation in the requested language"
    }
    """
    try:
        data = request.get_json()
        input_text = data['text'].strip()
        user_id = data.get('user_id')
        language_preference = data.get('language_preference', 'english').lower()
        
        logger.info(f"Explaining content for user {user_id} in {language_preference}: {len(input_text)} characters")
        
        # Generate explanation using Gemini AI 
        arabic_explanation, english_explanation = await gemini_service.explain_content(input_text)
        
        # Select the appropriate explanation based on language preference
        if language_preference == 'arabic':
            explanation = arabic_explanation
            response = {
                'explanation': explanation,
                'language': language_preference
            }
        elif language_preference == 'english':
            explanation = english_explanation
            response = {
                'explanation': explanation,
                'language': language_preference
            }
        elif language_preference == 'both':
            # Return both explanations
            response = {
                'arabic_explanation': arabic_explanation,
                'english_explanation': english_explanation,
                'language': language_preference
            }
            explanation = f"Arabic: {arabic_explanation}\n\nEnglish: {english_explanation}"
        else:
            # Default to English if invalid preference
            explanation = english_explanation
            response = {
                'explanation': explanation,
                'language': 'english'
            }
        
        # Store in database if user_id is provided
        session_id = None
        if user_id:
            try:
                session = await db_service.create_session(
                    user_id=user_id,
                    input_text=input_text,
                    output_explanation=explanation
                )
                session_id = session['id']
                logger.info(f"Stored explanation session {session_id} for user {user_id}")
            except Exception as db_error:
                logger.warning(f"Failed to store session in database: {db_error}")
                # Continue even if database storage fails
        
        if session_id:
            response['session_id'] = session_id
        
        return jsonify(response), 200
        
    except ValueError as e:
        logger.warning(f"Validation error in explain: {e}")
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in explain endpoint: {e}")
        return jsonify({
            'error': 'Failed to generate explanation',
            'message': str(e)
        }), 500

@api_bp.route('/generate_exercises', methods=['POST', 'OPTIONS'])
@validate_json_input(['text'])
@async_route
async def generate_exercises():
    """
    Generate educational exercises based on course content.
    
    Expected input:
    {
        "text": "copied course content or headings",
        "user_id": 1  // optional
    }
    
    Returns:
    {
        "exercises": [
            { "question": "...", "answer": "..." },
            { "question": "...", "answer": "..." },
            { "question": "...", "answer": "..." }
        ]
    }
    """
    try:
        data = request.get_json()
        input_text = data['text'].strip()
        user_id = data.get('user_id')
        language_preference = data.get('language_preference', 'english').lower()
        
        logger.info(f"Generating exercises for user {user_id} in {language_preference}: {len(input_text)} characters")
        
        # Generate exercises using Gemini AI
        exercises = await gemini_service.generate_exercises(input_text, language_preference)
        
        # Store in database if user_id is provided
        session_id = None
        if user_id:
            try:
                session = await db_service.create_session(
                    user_id=user_id,
                    input_text=input_text,
                    output_exercises=exercises
                )
                session_id = session['id']
                logger.info(f"Stored exercises session {session_id} for user {user_id}")
            except Exception as db_error:
                logger.warning(f"Failed to store session in database: {db_error}")
                # Continue even if database storage fails
        
        response = {
            'exercises': exercises
        }
        
        if session_id:
            response['session_id'] = session_id
        
        return jsonify(response), 200
        
    except ValueError as e:
        logger.warning(f"Validation error in generate_exercises: {e}")
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in generate_exercises endpoint: {e}")
        return jsonify({
            'error': 'Failed to generate exercises',
            'message': str(e)
        }), 500

@api_bp.route('/users', methods=['POST'])
@validate_json_input(['name', 'email'])
@async_route
async def create_user():
    """
    Create a new user.
    
    Expected input:
    {
        "name": "User Name",
        "email": "user@example.com",
        "language_pref": "english"  // optional, defaults to "english"
    }
    
    Returns:
    {
        "user": {
            "id": 1,
            "name": "User Name",
            "email": "user@example.com",
            "languagePref": "english",
            "createdAt": "2023-..."
        }
    }
    """
    try:
        data = request.get_json()
        name = data['name'].strip()
        email = data['email'].strip()
        language_pref = data.get('language_pref', 'english').strip()
        
        logger.info(f"Creating user: {email}")
        
        # Check if user already exists
        existing_user = await db_service.get_user_by_email(email)
        if existing_user:
            return jsonify({
                'error': 'User already exists',
                'message': f'User with email {email} already exists'
            }), 409
        
        # Create new user
        user = await db_service.create_user(name, email, language_pref)
        
        return jsonify({
            'user': user
        }), 201
        
    except ValueError as e:
        logger.warning(f"Validation error in create_user: {e}")
        return jsonify({
            'error': 'Invalid input',
            'message': str(e)
        }), 400
    except Exception as e:
        logger.error(f"Error in create_user endpoint: {e}")
        return jsonify({
            'error': 'Failed to create user',
            'message': str(e)
        }), 500

@api_bp.route('/users/<email>/sessions', methods=['GET'])
@async_route
async def get_user_sessions(email):
    """
    Get user's recent sessions.
    
    Returns:
    {
        "sessions": [
            {
                "id": 1,
                "inputText": "...",
                "outputSummary": "...",
                "outputExplanation": "...",
                "outputExercises": [...],
                "createdAt": "2023-...",
                "user": {...}
            }
        ]
    }
    """
    try:
        limit = request.args.get('limit', 10, type=int)
        if limit > 100:
            limit = 100  # Prevent excessive data retrieval
        
        logger.info(f"Getting sessions for user: {email}")
        
        # Get user first
        user = await db_service.get_user_by_email(email)
        if not user:
            return jsonify({
                'error': 'User not found',
                'message': f'User with email {email} not found'
            }), 404
        
        # Get user's sessions
        sessions = await db_service.get_user_sessions(user['id'], limit)
        
        return jsonify({
            'sessions': sessions
        }), 200
        
    except Exception as e:
        logger.error(f"Error in get_user_sessions endpoint: {e}")
        return jsonify({
            'error': 'Failed to retrieve sessions',
            'message': str(e)
        }), 500

@api_bp.errorhandler(404)
def not_found(error):
    """Handle 404 errors."""
    return jsonify({
        'error': 'Not found',
        'message': 'The requested resource was not found'
    }), 404

@api_bp.errorhandler(405)
def method_not_allowed(error):
    """Handle 405 errors."""
    return jsonify({
        'error': 'Method not allowed',
        'message': 'The method is not allowed for the requested URL'
    }), 405

@api_bp.errorhandler(500)
def internal_error(error):
    """Handle 500 errors."""
    logger.error(f"Internal server error: {error}")
    return jsonify({
        'error': 'Internal server error',
        'message': 'An unexpected error occurred'
    }), 500
